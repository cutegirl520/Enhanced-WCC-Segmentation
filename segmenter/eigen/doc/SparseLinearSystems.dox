namespace Eigen {
/** \eigenManualPage TopicSparseSystems Solving Sparse Linear Systems
In Eigen, there are several methods available to solve linear systems when the coefficient matrix is sparse. Because of the special representation of this class of matrices, special care should be taken in order to get a good performance. See \ref TutorialSparse for a detailed introduction about sparse matrices in Eigen. This page lists the sparse solvers available in Eigen. The main steps that are common to all these linear solvers are introduced as well. Depending on the properties of the matrix, the desired accuracy, the end-user is able to tune those steps in order to improve the performance of its code. Note that it is not required to know deeply what's hiding behind these steps: the last section presents a benchmark routine that can be easily used to get an insight on the performance of all the available solvers. 

\eigenAutoToc

\section TutorialSparseSolverList List of sparse solvers

%Eigen currently provides a wide set of built-in solvers, as well as wrappers to external solver libraries.
They are summarized in the following tables:

\subsection TutorialSparseSolverList_Direct Built-in direct solvers

<table class="manual">
<tr><th>Class</th><th>Solver kind</th><th>Matrix kind</th><th>Features related to performance</th>
    <th>License</th><th class="width20em"><p>Notes</p></th></tr>

<tr><td>SimplicialLLT \n <tt>\#include<Eigen/\link SparseCholesky_Module SparseCholesky\endlink></tt></td><td>Direct LLt factorization</td><td>SPD</td><td>Fill-in reducing</td>
    <td>LGPL</td>
    <td>SimplicialLDLT is often preferable</td></tr>

<tr><td>SimplicialLDLT \n <tt>\#include<Eigen/\link SparseCholesky_Module SparseCholesky\endlink></tt></td><td>Direct LDLt factorization</td><td>SPD</td><td>Fill-in reducing</td>
    <td>LGPL</td>
    <td>Recommended for very sparse and not too large problems (e.g., 2D Poisson eq.)</td></tr>

<tr><td>SparseLU \n <tt>\#include<Eigen/\link SparseLU_Module SparseLU\endlink></tt></td> <td>LU factorization </td>
    <td>Square </td><td>Fill-in reducing, Leverage fast dense algebra</td>
    <td>MPL2</td>
    <td>optimized for small and large problems with irregular patterns </td></tr>

<tr><td>SparseQR \n <tt>\#include<Eigen/\link SparseQR_Module SparseQR\endlink></tt></td> <td> QR factorization</td>
    <td>Any, rectangular</td><td> Fill-in reducing</td>
    <td>MPL2</td>
    <td>recommended for least-square problems, has a basic rank-revealing feature</td></tr>
 </table>

\subsection TutorialSparseSolverList_Iterative Built-in iterative solvers

<table class="manual">
<tr><th>Class</th><th>Solver kind</th><th>Matrix kind</th><th>Supported preconditioners, [default]</th>
    <th>License</th><th class="width20em"><p>Notes</p></th></tr>

<tr><td>ConjugateGradient \n <tt>\#include<Eigen/\link IterativeLinearSolvers_Module IterativeLinearSolvers\endlink></tt></td> <td>Classic iterative CG</td><td>SPD</td>
    <td>IdentityPreconditioner, [DiagonalPreconditioner], IncompleteCholesky</td>
    <td>MPL2</td>
    <td>Recommended for large symmetric problems (e.g., 3D Poisson eq.)</td></tr>

<tr><td>LeastSquaresConjugateGradient \n <tt>\#include<Eigen/\link IterativeLinearSolvers_Module IterativeLinearSolvers\endlink></tt></td><td>CG for rectangular least-square problem</td><td>Rectangular</td>
    <td>IdentityPreconditioner, [LeastSquareDiagonalPreconditioner]</td>
    <td>MPL2</td>
    <td>Solve for min |A'Ax-b|^2 without forming A'A</td></tr>

<tr><td>BiCGSTAB \n <tt>\#include<Eigen/\link IterativeLinearSolvers_Module IterativeLinearSolvers\endlink></tt></td><td>Iterative stabilized bi-conjugate gradient</td><td>Square</td>
    <td>IdentityPreconditioner, [DiagonalPreconditioner], IncompleteLUT</td>
    <td>MPL2</td>
    <td>To speedup the convergence, try it with the \ref IncompleteLUT preconditioner.</td></tr>
</table>

\subsection TutorialSparseSolverList_Wrapper Wrappers to external solvers

<table class="manual">
<tr><th>Class</th><th>Module</th><th>Solver kind</th><th>Matrix kind</th><th>Features related to performance</th>
    <th>Dependencies,License</th><th class="width20em"><p>Notes</p></th></tr>
<tr><td>PastixLLT \n PastixLDLT \n PastixLU</td><td>\link PaStiXSupport_Module PaStiXSupport \endlink</td><td>Direct LLt, LDLt, LU factorizations</td><td>SPD \n SPD \n Square</td><td>Fill-in reducing, Leverage fast dense algebra, Multithreading</td>
    <td>Requires the <a href="http://pastix.gforge.inria.fr">PaStiX</a> package, \b CeCILL-C </td>
    <td>optimized for tough problems and symmetric patterns</td></tr>
<tr><td>CholmodSupernodalLLT</td><td>\link CholmodSupport_Module CholmodSupport \endlink</td><td>Direct LLt factorization</td><td>SPD</td><td>Fill-in reducing, Leverage fast dense algebra</td>
    <td>Requires the <a href="http://www.suitesparse.com">SuiteSparse</a> package, \b GPL </td>
    <td></td></tr>
<tr><td>UmfPackLU</td><td>\link UmfPackSupport_Module UmfPackSupport \endlink</td><td>Direct LU factorization</td><td>Square</td><td>Fill-in reducing, Leverage fast dense algebra</td>
    <td>Requires the <a href="http://www.suitesparse.com">SuiteSparse</a> package, \b GPL </td>
    <td></td></tr>
<tr><td>SuperLU</td><td>\link SuperLUSupport_Module SuperLUSupport \endlink</td><td>Direct LU factorization</td><td>Square</td><td>Fill-in reducing, Leverage fast dense algebra</td>
    <td>Requires the <a href="http://crd-legacy.lbl.gov/~xiaoye/SuperLU/">SuperLU</a> library, (BSD-like)</td>
    <td></td></tr>
<tr><td>SPQR</td><td>\link SPQRSupport_Module SPQRSupport \endlink  </td> <td> QR factorization </td> 
    <td> Any, rectangular</td><td>fill-in reducing, multithreaded, fast dense algebra</td>
    <td> requires the <a href="http://www.suitesparse.com">SuiteSparse</a> package, \b GPL </td><td>recommended for linear least-squares problems, has a rank-revealing feature</tr>
</table>

Here \c SPD means symmetric positive definite.

\section TutorialSparseSolverConcept Sparse solver concept

All these solvers follow the same general concept.
Here is a typical and general example:
\code
#include <Eigen/RequiredModuleName>
// ...
SparseMatrix<double> A;
// fill A
VectorXd b, x;
// fill b
// solve Ax = b
SolverClassName<SparseMatrix<double> > solver;
solver.compute(A);
if(solver.info()!=Success) {
  // decomposition failed
  return;
}
x = solver.solve(b);
if(solver.info()!=Success) {
  // solving failed
  return;
}
// solve for another right hand side:
x1 = solver.solve(b1);
\endcode

For \c SPD solvers, a second optional template argument allows to specify which triangular part have to be used, e.g.:

\code
#include <Eigen/IterativeLinearSolvers>

ConjugateGradient<SparseMatrix<double>, Eigen::Upper> solver;
x = solver.compute(A).solve(b);
\endcode
In the above example, only the upper triangular part of the input matrix A is considered for solving. The opposite triangle might either be empty or contain arbitrary values.

In the case where multiple problems with the same sparsity pattern have to be solved, then the "compute" step can be decomposed as follow:
\code
SolverClassName<SparseMatrix<double> > solver;
solver.analyzePattern(A);   // for this step the numerical values of A are not used
solver.factorize(A);
x1 = solver.solve(b1);
x2 = solver.solve(b2);
...
A = ...;                    // modify the values of the nonzeros of A, the nonzeros pattern must stay unchanged
solver.factorize(A);
x1 = solver.solve(b1);
x2 = solver.solve(b2);
...
\endcode
The compute() method is equivalent to calling both analyzePattern() and factorize().

Each solver provides some specific features,