namespace Eigen {

/** \eigenManualPage TutorialMapClass Interfacing with raw buffers: the Map class

This page explains how to work with "raw" C/C++ arrays.
This can be useful in a variety of contexts, particularly when "importing" vectors and matrices from other libraries into %Eigen.

\eigenAutoToc

\section TutorialMapIntroduction Introduction

Occasionally you may have a pre-defined array of numbers that you want to use within %Eigen as a vector or matrix. While one option is to make a copy of the data, most commonly you probably want to re-use this memory as an %Eigen type. Fortunately, this is very easy with the Map class.

\section TutorialMapTypes Map types and declaring Map variables

A Map object has a type defined by its %Eigen equivalent:
\code
Map<Matrix<typename Scalar, int RowsAtCompileTime, int ColsAtCompileTime> >
\endcode
Note that, in this default case, a Map requires just a single template parameter.  

To construct a Map variable, you need two other pieces of information: a pointer to the region of memory defining the array of coefficients, and the desired shape of the matrix or vector.  For example, to define a matrix of \c float with sizes determined at compile time, you might do the following:
\code
Map<MatrixXf> mf(pf,rows,columns);
\endcode
where \c pf is a \c float \c * pointing to the array of memory.  A fixed-size read-only vector of integers might be declared as
\code
Map<const Vector4i> mi(pi);
\endcode
where \c pi is an \c int \c *. In this case the size does not have to be passed to the constructor, because it is already specified by the Matrix/Array type.

Note that Map does not have a default constructor; you \em must pass a pointer to intialize the object. However, you can work around this requirement (see \ref TutorialMapPlacementNew).

Map is flexible enough to accomodate a variety of different data representations.  There are two other (optional) template parameters:
\code
Map<typename MatrixType,
    int MapOptions,
    typename StrideType>
\endcode
\li \c MapOptions specifies whether the pointer is \c #Aligned, or \c #Unaligned.  The default is \c #Unaligned.
\li \c StrideTyp